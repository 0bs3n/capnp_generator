@0xdbb9ad1f14bf0b36;  # unique file ID, generated by `capnp id`

using Types = import "example_import.capnp";

struct ExposesInternalStructs {
  struct ExposesInternalEnums {
    enum TestEnum {
      zero @0;
      one @1;
      two @2;
    }
    internalEnum @0 :TestEnum;
  }
  internalStruct @0 :ExposesInternalEnums;
}

struct Person {
  name @0 :Text;
  email @1 :Text;
  phones @25 :List(PhoneNumber);
  company @2 :Company;
  birthdate @3 :Types.Date;
  addressType @4 :Types.AddressType;
  a @5 :UInt8;
  b @6 :UInt16;
  c @7 :UInt32;
  d @8 :UInt64;
  e @9 :Int8;
  f @10 :Int16;
  g @11 :Int32;
  h @12 :Int64;
  i @13 :Float32;
  j @14 :Float64;
  k @15 :Bool;
  data @16 :Data;
  mainPhone @17 :PhoneNumber;
  testList @18 :List(Bool);
  recursiveStruct @19 :Person;
  struct PhoneNumber {
    number @0 :Text;
    type @1 :Type;

    enum Type {
      mobile @0;
      home @1;
      work @2;
    }
  }
  employment :union {
    # We assume that a person is only one of these.
    selfEmployed @20 :UInt32;
    employer @21 :Company;
    school @22 :School;
    unemployed @23 :Void;
    nestedEmployed @24 :PhoneNumber;
    importEmployed @27 :Types.Date;
    importEmployedEnum @26 :Types.AddressType;
  }
  localImport @28 :ExposesInternalStructs.ExposesInternalEnums.TestEnum;
}

struct Company {
  id @0 :UInt16;
}
struct School {
  id @0 :UInt16;
}

const testConst :Float32 = 3.14;

interface TestInterface {
  returnOpposite @0 (input :Bool) -> (output :Bool);
}
